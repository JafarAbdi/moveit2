"""Simplify loading moveit config parameters.

This module provides builder-pattern based class to simplify loading moveit related parameters found in
ROBOT_moveit_config package generated by moveit setup assistant.

This package is a successor to moveit_configs_utils package. It is designed to be used to be more flexible and easier to use.
Main differences are:
    - No implicit loading of default parameters. All parameters must be explicitly loaded by calling the corresponding function.
        - This is to avoid loading parameters that are not needed, sometimes only a few parameters are needed.
        - If you want to load all the parameters, you can use the load_all function.
    - Package name has to be explicitly provided. Previously it was implicitly loaded by appending _moveit_config to the robot name.
    - Does not require the moveit config package to be installed. It can be used to load parameters from the path to the package. -- TODO(Jafar)
    - No longer autoloads the values from the URDF and SRDF tags from .setup_assistant file.
    - Remove all the complicated logic for loading moveit controller manager, planning pipeline, and urdf/srdf parameters.
    - Support loading moveit_config.toml file for default values. -- TODO(Jafar)
    - Add support for loading parameters for servo. -- TODO(Jafar)

moveit_config.toml 

```toml
[moveit_configs]
robot_description = "config/my_robot.urdf.xacro"
robot_description_semantic = "config/my_robot.srdf.xacro"
robot_description_kinematics = "config/kinematics.yaml"
planning_pipelines.ompl = "config/ompl_planning.yaml"
planning_pipelines.chomp = "config/chomp_planning.yaml"
planning_pipelines.trajopt = "config/trajopt_planning.yaml"
planning_pipelines.pilz = "config/pilz_planning.yaml"
planning_pipelines.stomp = "config/stomp_planning.yaml"
planning_pipelines.CUSTOM_PLANNER = "config/PLANNER.yaml"
trajectory_execution = "config/trajectory_execution.yaml"
sensors = "config/sensors_3d.yaml"
joint_limits = "config/joint_limits.yaml"
moveit_cpp = "config/moveit_cpp.yaml"
# TODO(Jafar): Support this
# move_group = ""

[robot_description]
mapping1 = "value1"
mapping2 = "value2"

[robot_description_semantic]
mapping1 = "value1"
mapping2 = "value2"

[robot_description_kinematics]
mapping1 = "value1"
mapping2 = "value2"

# Applies to all planning pipelines
[planning_pipelines]
mapping1 = "value1"
mapping2 = "value2"

[planning_pipelines.ompl]
mapping1 = "value1"
mapping2 = "value2"

[planning_pipelines.chomp]
mapping1 = "value1"
mapping2 = "value2"

[trajectory_execution]
mapping1 = "value1"
mapping2 = "value2"

[sensors]
mapping1 = "value1"
mapping2 = "value2"

[joint_limits]
mapping1 = "value1"
mapping2 = "value2"

[moveit_cpp]
mapping1 = "value1"
mapping2 = "value2"

# TODO(Jafar): Support this
# [move_group]
# mapping1 = "asd"
# mapping2 = "asd"
```

# TODO(Jafar): Remove
If not provided, and the corresponding function is called, it will try to load the following files from the config folder

```toml
[moveit_configs]
robot_description = "config/robot.urdf.xacro"
robot_description_semantic = "config/robot.srdf.xacro"
robot_description_kinematics = "config/kinematics.yaml"
planning_pipelines.XXXX = "config/XXXX_planning.yaml"
trajectory_execution = "config/trajectory_execution.yaml"
sensors = "config/sensors_3d.yaml"
joint_limits = "config/joint_limits.yaml"
moveit_cpp = "config/moveit_cpp.yaml"
# TODO(Jafar): Support this
# move_group = "config/move_group_capabilities.yaml"
```



By default it expects the following structure for the moveit configs package

ROBOT_NAME_moveit_config/
    moveit_config.toml
    config/
        kinematics.yaml -> IK solver's parameters
        joint_limits.yaml -> Overriding position/velocity/acceleration limits from the URDF file
        moveit_cpp.yaml -> MoveItCpp related parameters
        *_planning.yaml -> planning pipelines parameters
        pilz_cartesian_limits.yaml -> Pilz planner parameters
        moveit_controllers.yaml -> trajectory execution manager's parameters
        ...

Example:
    moveit_configs = MoveItConfigsBuilder("robot_name").to_moveit_configs()
    ...
    moveit_configs.package_path
    moveit_configs.robot_description
    moveit_configs.robot_description_semantic
    moveit_configs.robot_description_kinematics
    moveit_configs.planning_pipelines
    moveit_configs.trajectory_execution
    moveit_configs.planning_scene_monitor
    moveit_configs.sensors_3d
    moveit_configs.move_group_capabilities
    moveit_configs.joint_limits
    moveit_configs.moveit_cpp
    moveit_configs.pilz_cartesian_limits
    # Or to get all the parameters as a dictionary
    moveit_configs.to_dict()

Each function in MoveItConfigsBuilder has a file_path as an argument which is used to override the default
path for the file

Example:
    moveit_configs = MoveItConfigsBuilder("robot_name")
                    # Relative to robot_name_moveit_configs
                    .robot_description_semantic(Path("my_config") / "my_file.srdf")
                    .to_moveit_configs()
    # Or
    moveit_configs = MoveItConfigsBuilder("robot_name")
                    # Absolute path to robot_name_moveit_config
                    .robot_description_semantic(Path.home() / "my_config" / "new_file.srdf")
                    .to_moveit_configs()
"""

from pathlib import Path
from typing import Optional
from dataclasses import dataclass, field, InitVar
from ament_index_python.packages import get_package_share_directory
import toml

from launch_param_builder import (
    load_yaml,
    load_xacro,
    raise_if_file_not_found,
)
from moveit_configs_utils.substitutions import Xacro
from launch.some_substitutions_type import SomeSubstitutionsType
from launch_ros.parameter_descriptions import ParameterValue
from enum import Enum


class ConfigSections(str, Enum):
    MOVEIT_CONFIGS = "moveit_configs"
    ROBOT_DESCRIPTION = "robot_description"
    ROBOT_DESCRIPTION_SEMANTIC = "robot_description_semantic"
    SENSORS = "sensors"
    MOVEIT_CPP = "moveit_cpp"
    ROBOT_DESCRIPTION_KINEMATICS = "robot_description_kinematics"
    JOINT_LIMITS = "joint_limits"
    TRAJECTORY_EXECUTION = "trajectory_execution"
    PLANNING_PIPELINES = "planning_pipelines"


@dataclass(slots=True)
class ConfigEntry:
    path: Path
    mappings: dict


@dataclass(slots=True)
class PlanningPipelinesConfigEntry:
    pipelines: list[str]
    configs: list[ConfigEntry]
    default_planning_pipeline: str


@dataclass(slots=True)
class MoveItConfigs:
    """Class containing MoveIt related parameters."""

    # A pathlib Path to the moveit config package
    package_path: Optional[str] = None
    # A dictionary that has the contents of the URDF file.
    robot_description: dict = field(default_factory=dict)
    # A dictionary that has the contents of the SRDF file.
    robot_description_semantic: dict = field(default_factory=dict)
    # A dictionary IK solver specific parameters.
    robot_description_kinematics: dict = field(default_factory=dict)
    # A dictionary that contains the planning pipelines parameters.
    planning_pipelines: dict = field(default_factory=dict)
    # A dictionary contains parameters for trajectory execution & moveit controller managers.
    trajectory_execution: dict = field(default_factory=dict)
    # A dictionary that has the planning scene monitor's parameters.
    planning_scene_monitor: dict = field(default_factory=dict)
    # A dictionary that has the sensor 3d configuration parameters.
    sensors_3d: dict = field(default_factory=dict)
    # A dictionary containing move_group's non-default capabilities.
    move_group_capabilities: dict = field(default_factory=dict)
    # A dictionary containing the overridden position/velocity/acceleration limits.
    joint_limits: dict = field(default_factory=dict)
    # A dictionary containing MoveItCpp related parameters.
    moveit_cpp: dict = field(default_factory=dict)
    # A dictionary containing the cartesian limits for the Pilz planner.
    pilz_cartesian_limits: dict = field(default_factory=dict)

    def to_dict(self):
        parameters = {}
        parameters.update(self.robot_description)
        parameters.update(self.robot_description_semantic)
        parameters.update(self.robot_description_kinematics)
        parameters.update(self.planning_pipelines)
        parameters.update(self.trajectory_execution)
        parameters.update(self.planning_scene_monitor)
        parameters.update(self.sensors_3d)
        parameters.update(self.joint_limits)
        parameters.update(self.moveit_cpp)
        # Update robot_description_planning with pilz cartesian limits
        if self.pilz_cartesian_limits:
            parameters["robot_description_planning"].update(
                self.pilz_cartesian_limits["robot_description_planning"]
            )
        return parameters


@dataclass(slots=True)
class MoveItConfigsBuilder:
    package_name: InitVar[str] = None
    package_path: Optional[Path] = None
    _robot_description_config: Optional[ConfigEntry] = None
    _robot_description_semantic_config: Optional[ConfigEntry] = None
    _robot_description_kinematics_config: Optional[ConfigEntry] = None
    _planning_pipelines_config: Optional[PlanningPipelinesConfigEntry] = None
    _trajectory_execution_config: Optional[ConfigEntry] = None
    # planning_scene_monitor_config: Optional[ConfigEntry] = None
    _sensors_config: Optional[ConfigEntry] = None
    _joint_limits_config: Optional[ConfigEntry] = None
    _moveit_cpp_config: Optional[ConfigEntry] = None
    _default_configs: dict = field(default_factory=dict)

    def __post_init__(self, package_name: str):
        self.package_path = Path(get_package_share_directory(package_name))
        if (
            default_moveit_configs_path := self.package_path / "moveit_configs.toml"
        ).exists():
            self._default_configs = toml.load(default_moveit_configs_path)

    def _make_config_entry_from_file(
        self, file_path: Path, mappings: Optional[dict] = None
    ):
        raise_if_file_not_found(file_path)
        return ConfigEntry(
            path=file_path,
            mappings=mappings or {},
        )

    def _make_config_entry_from_section(
        self, section: ConfigSections, option: Optional[str] = None
    ):
        if not self._default_configs:
            raise RuntimeError(
                "Default configs are not loaded. Please provide a moveit_configs.toml file."
            )

        if (
            moveit_configs := self._default_configs.get(ConfigSections.MOVEIT_CONFIGS)
        ) is None:
            raise RuntimeError(
                "No [moveit_configs] section found in moveit_configs.toml"
            )

        if (value := moveit_configs.get(section)) is None:
            raise RuntimeError(
                f"No value {section} found for [moveit_configs] section in moveit_configs.toml"
            )

        if option and (value := value.get(option)) is None:
            raise RuntimeError(
                f"No value {section}.{option} found for [moveit_configs] section in moveit_configs.toml"
            )

        return ConfigEntry(
            path=self.package_path / value,
            mappings=moveit_configs.get(section, {}).get(option, {})
            if option
            else moveit_configs.get(section, {}),
        )

    def robot_description(
        self,
        file_path: Optional[str] = None,
        mappings: Optional[dict[SomeSubstitutionsType, SomeSubstitutionsType]] = None,
    ):
        """Load robot description.

        :param file_path: Absolute or relative path to the URDF file (w.r.t. robot_name_moveit_config).
        :param mappings: mappings to be passed when loading the xacro file.
        :return: Instance of MoveItConfigsBuilder with robot_description loaded.
        """
        if file_path:
            self._robot_description_config = self._make_config_entry_from_file(
                self.package_path / file_path, mappings
            )
        else:
            self._robot_description_config = self._make_config_entry_from_section(
                ConfigSections.ROBOT_DESCRIPTION
            )

        return self

    def robot_description_semantic(
        self,
        file_path: Optional[str] = None,
        mappings: dict[SomeSubstitutionsType, SomeSubstitutionsType] = None,
    ):
        """Load semantic robot description.

        :param file_path: Absolute or relative path to the SRDF file (w.r.t. robot_name_moveit_config).
        :param mappings: mappings to be passed when loading the xacro file.
        :return: Instance of MoveItConfigsBuilder with robot_description_semantic loaded.
        """

        if file_path:
            self._robot_description_semantic_config = self._make_config_entry_from_file(
                self.package_path / file_path, mappings
            )
        else:
            self._robot_description_semantic_config = (
                self._make_config_entry_from_section(
                    ConfigSections.ROBOT_DESCRIPTION_SEMANTIC
                )
            )

        return self

    def robot_description_kinematics(
        self, file_path: Optional[str] = None, mappings: Optional[dict] = None
    ):
        """Load IK solver parameters.

        :param file_path: Absolute or relative path to the kinematics yaml file (w.r.t. robot_name_moveit_config).
        :return: Instance of MoveItConfigsBuilder with robot_description_kinematics loaded.
        """
        if file_path:
            self._robot_description_kinematics_config = (
                self._make_config_entry_from_file(
                    self.package_path / file_path, mappings
                )
            )
        else:
            self._robot_description_kinematics_config = (
                self._make_config_entry_from_section(
                    ConfigSections.ROBOT_DESCRIPTION_KINEMATICS
                )
            )

        return self

    def joint_limits(
        self, file_path: Optional[str] = None, mappings: Optional[dict] = None
    ):
        """Load joint limits overrides.

        :param file_path: Absolute or relative path to the joint limits yaml file (w.r.t. robot_name_moveit_config).
        :return: Instance of MoveItConfigsBuilder with robot_description_planning loaded.
        """
        if file_path:
            self._joint_limits_config = self._make_config_entry_from_file(
                self.package_path / file_path, mappings
            )
        else:
            self._joint_limits_config = self._make_config_entry_from_section(
                ConfigSections.JOINT_LIMITS
            )

        return self

    def moveit_cpp(
        self, file_path: Optional[str] = None, mappings: Optional[dict] = None
    ):
        """Load MoveItCpp parameters.

        :param file_path: Absolute or relative path to the MoveItCpp yaml file (w.r.t. robot_name_moveit_config).
        :return: Instance of MoveItConfigsBuilder with moveit_cpp loaded.
        """
        if file_path:
            self._moveit_cpp_config = self._make_config_entry_from_file(
                self.package_path / file_path, mappings
            )
        else:
            self._moveit_cpp_config = self._make_config_entry_from_section(
                ConfigSections.MOVEIT_CPP
            )
        return self

    def trajectory_execution(
        self,
        file_path: Optional[str] = None,
        mappings: Optional[dict] = None,
    ):
        """Load trajectory execution and moveit controller managers' parameters

        :param file_path: Absolute or relative path to the controllers yaml file (w.r.t. robot_name_moveit_config).
        :return: Instance of MoveItConfigsBuilder with trajectory_execution loaded.
        """
        if file_path:
            self._trajectory_execution_config = self._make_config_entry_from_file(
                self.package_path / file_path, mappings
            )
        else:
            self._trajectory_execution_config = self._make_config_entry_from_section(
                ConfigSections.TRAJECTORY_EXECUTION
            )

        return self

    # TODO(Jafar): This's only for move_group move to a separate config file
    # def planning_scene_monitor(
    #     self,
    #     publish_planning_scene: bool = True,
    #     publish_geometry_updates: bool = True,
    #     publish_state_updates: bool = True,
    #     publish_transforms_updates: bool = True,
    #     publish_robot_description: bool = False,
    #     publish_robot_description_semantic: bool = False,
    # ):
    #     moveit_configs.planning_scene_monitor = {
    #         # TODO: Fix parameter namespace upstream -- see planning_scene_monitor.cpp:262
    #         # "planning_scene_monitor": {
    #         "publish_planning_scene": publish_planning_scene,
    #         "publish_geometry_updates": publish_geometry_updates,
    #         "publish_state_updates": publish_state_updates,
    #         "publish_transforms_updates": publish_transforms_updates,
    #         "publish_robot_description": publish_robot_description,
    #         "publish_robot_description_semantic": publish_robot_description_semantic,
    #         # }
    #     }
    #     return self

    def sensors(self, file_path: Optional[str] = None, mappings: Optional[dict] = None):
        """Load sensors_3d parameters.

        :param file_path: Absolute or relative path to the sensors_3d yaml file (w.r.t. robot_name_moveit_config).
        :return: Instance of MoveItConfigsBuilder with robot_description_planning loaded.
        """
        if file_path:
            self._sensors_config = self._make_config_entry_from_file(
                self.package_path / file_path, mappings
            )
        else:
            self._sensors_config = self._make_config_entry_from_section(
                ConfigSections.SENSORS
            )
        return self

    def planning_pipelines(
        self,
        pipelines: Optional[List[str]] = None,
        default_planning_pipeline: Optional[str] = None,
        mappings: Optional[dict] = None,
    ):
        """Load planning pipelines parameters.

        :param default_planning_pipeline: Name of the default planning pipeline.
        :param pipelines: List of the planning pipelines to be loaded.
        :return: Instance of MoveItConfigsBuilder with planning_pipelines loaded.
        """

        # If no pipelines are specified, use ompl by default
        if pipelines is not None:
            planning_pipelines_configs = [
                self._make_config_entry_from_file(
                    self.package_path / "config" / f"{pipeline}_planning.yaml", mappings
                )
                for pipeline in pipelines
            ]
        else:
            planning_pipelines_configs = [
                self._make_config_entry_from_section(
                    ConfigSections.PLANNING_PIPELINES, planner
                )
                for planner in pipelines
            ]

        # Define default pipeline as needed
        if not default_planning_pipeline:
            if "ompl" in pipelines:
                default_planning_pipeline = "ompl"

        if default_planning_pipeline not in pipelines:
            raise RuntimeError(
                f"default_planning_pipeline: `{default_planning_pipeline}` doesn't name any of the input pipelines "
                f"`{','.join(pipelines)}`"
            )

        self._planning_pipelines_config = PlanningPipelinesConfigEntry(
            pipelines=pipelines.copy(),
            default_planning_pipeline=default_planning_pipeline,
            configs=planning_pipelines_configs,
        )

        return self

    # def pilz_cartesian_limits(
    #     self, file_path: Optional[str] = None, mappings: Optional[dict] = None
    # ):
    #     """Load cartesian limits.

    #     :param file_path: Absolute or relative path to the cartesian limits file (w.r.t. robot_name_moveit_config).
    #     :return: Instance of MoveItConfigsBuilder with pilz_cartesian_limits loaded.
    #     """
    #     moveit_configs.pilz_cartesian_limits = {
    #         "robot_description_planning": load_yaml(
    #             self.package_path
    #             / (
    #                 file_path
    #                 or config_dir_path / DefaultConfigFiles.PILZ_CARTESIAN_LIMITS
    #             ),
    #             mappings,
    #         )
    #     }
    #     return self

    def to_moveit_configs(self):
        """Get MoveIt configs from ROBOT_NAME_moveit_config.

        :return: An MoveItConfigs instance with all parameters loaded.
        """
        moveit_configs = MoveItConfigs()
        if self._robot_description_config is not None:
            # If mappings is None or a dictionary of strings, load the xacro file as a string.
            # Otherwise, load it as a ParameterValue.
            # This makes it possible to use the builder with MoveItPy while still being able to
            # use a ros2 launch's substitution types.
            if (self._robot_description_config.mappings is None) or all(
                (isinstance(key, str) and isinstance(value, str))
                for key, value in self._robot_description_config.mappings.items()
            ):
                moveit_configs.robot_description = {
                    "robot_description": load_xacro(
                        self._robot_description_config.path,
                        mappings=self._robot_description_config.mappings,
                    )
                }
            else:
                moveit_configs.robot_description = {
                    "robot_description": ParameterValue(
                        Xacro(
                            str(robot_description_file_path),
                            mappings=self._robot_description_config.mappings,
                        ),
                        value_type=str,
                    )
                }

        if self._robot_description_semantic_config is not None:
            # Support both MoveItPy and ros2 launch substitution types similar to robot_description
            if (self._robot_description_semantic_config.mappings is None) or all(
                (isinstance(key, str) and isinstance(value, str))
                for key, value in self._robot_description_semantic_config.mappings.items()
            ):
                moveit_configs.robot_description_semantic = {
                    "robot_description_semantic": load_xacro(
                        self._robot_description_semantic_config.path,
                        mappings=self._robot_description_semantic_config.mappings,
                    )
                }
            else:
                moveit_configs.robot_description_semantic = {
                    "robot_description_semantic": ParameterValue(
                        Xacro(
                            str(self._robot_description_semantic_config.path),
                            mappings=self._robot_description_semantic_config.mappings,
                        ),
                        value_type=str,
                    )
                }

        if self._robot_description_kinematics_config is not None:
            moveit_configs.robot_description_kinematics = {
                "robot_description_kinematics": load_yaml(
                    self._robot_description_kinematics_config.path,
                    mappings=self._robot_description_kinematics_config.mappings,
                )
            }

        if self._planning_pipelines_config:
            moveit_configs.planning_pipelines = {
                "planning_pipelines": self._planning_pipelines_config.pipelines,
                "default_planning_pipeline": self._planning_pipelines_config.default_planning_pipeline,
            }
            for pipeline, pipeline_config in zip(
                self._planning_pipelines_config.pipelines,
                self._planning_pipelines_config.configs,
            ):
                moveit_configs.planning_pipelines[pipeline] = load_yaml(
                    file_path=pipeline_config.path,
                    mappings=pipeline_config.mappings,
                )

        if self._trajectory_execution_config is not None:
            moveit_configs.trajectory_execution = load_yaml(
                self._trajectory_execution_config.path,
                mappings=self._trajectory_execution_config.mappings,
            )

        if self._sensors_config is not None:
            moveit_configs.sensors_3d = load_yaml(
                self._sensors_config.path,
                mappings=self._sensors_config.mappings,
            )

        if self._joint_limits_config is not None:
            moveit_configs.joint_limits = {
                "robot_description_planning": load_yaml(
                    self._joint_limits_config.path,
                    mappings=self._joint_limits_config.mappings,
                )
            }

        if self._moveit_cpp_config is not None:
            moveit_configs.moveit_cpp = load_yaml(
                self._moveit_cpp_config.path,
                mappings=self._moveit_cpp_config.mappings,
            )

        # if not moveit_configs.planning_scene_monitor:
        #     self.planning_scene_monitor()
        # if "pilz_industrial_motion_planner" in moveit_configs.planning_pipelines:
        #     if not moveit_configs.pilz_cartesian_limits:
        #         self.pilz_cartesian_limits()
        return moveit_configs
